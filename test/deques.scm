(library (test deques)
  (export deques)
  (import (rnrs (6))
          (chez-test suite)
          (chez-test assertions)
          (test utils)
          (pfds deques))
  
  (define-test-suite deques
    "Tests for the functional deque implementation")
  
  (define-test-case deques empty-deque ()
    (assert-predicate deque? (make-deque))
    (assert-predicate deque-empty? (make-deque))
    (assert-eqv 0 (deque-length (make-deque))))
  
  (define-test-case deques deque-insert ()
    (let ((deq (enqueue-front (make-deque) 'foo)))
      (assert-predicate deque? deq)
      (assert-eqv 1 (deque-length deq)))
    (let ((deq (enqueue-rear (make-deque) 'foo)))
      (assert-predicate deque? deq)
      (assert-eqv 1 (deque-length deq)))
    (assert-eqv 5 (deque-length
                 (fold-left (lambda (deque pair)
                          ((car pair) deque (cdr pair)))
                        (make-deque)
                        `((,enqueue-front . 0)
                          (,enqueue-rear  . 1)
                          (,enqueue-front . 2)
                          (,enqueue-rear  . 3)
                          (,enqueue-front . 4))))))
  
  (define-test-case deques deque-remove ()
    (let ((deq (enqueue-front (make-deque) 'foo)))
      (let-values (((item0 deque0) (dequeue-front deq))
                   ((item1 deque1) (dequeue-rear deq)))
        (assert-eqv 'foo item0)
        (assert-eqv 'foo item1)
        (assert-predicate deque-empty? deque0)
        (assert-predicate deque-empty? deque1)))
    (let ((deq (fold-left (lambda (deque item)
                        (enqueue-rear deque item))
                      (make-deque)
                      '(0 1 2 3 4 5))))
      (let*-values (((item0 deque0) (dequeue-front deq))
                    ((item1 deque1) (dequeue-front deque0))
                    ((item2 deque2) (dequeue-front deque1)))
        (assert-eqv 0 item0)
        (assert-eqv 1 item1)
        (assert-eqv 2 item2)
        (assert-eqv 3 (deque-length deque2))))
    (let ((deq (fold-left (lambda (deque item)
                        (enqueue-rear deque item))
                      (make-deque)
                      '(0 1 2 3 4 5))))
      (let*-values (((item0 deque0) (dequeue-rear deq))
                    ((item1 deque1) (dequeue-rear deque0))
                    ((item2 deque2) (dequeue-rear deque1)))
        (assert-eqv 5 item0)
        (assert-eqv 4 item1)
        (assert-eqv 3 item2)
        (assert-eqv 3 (deque-length deque2))))
    (let ((empty (make-deque)))
      (assert-eqv #t
                (guard (exn ((deque-empty-condition? exn) #t)
                            (else #f))
                  (dequeue-front empty)
                  #f))
      (assert-eqv #t
                (guard (exn ((deque-empty-condition? exn) #t)
                            (else #f))
                  (dequeue-rear empty)
                  #f))))
  
  
  (define-test-case deques mixed-operations ()
    (let ((deque (fold-left (lambda (deque pair)
                          ((car pair) deque (cdr pair)))
                        (make-deque)
                        `((,enqueue-front . 0)
                          (,enqueue-rear  . 1)
                          (,enqueue-front . 2)
                          (,enqueue-rear  . 3)
                          (,enqueue-front . 4)))))
      (let*-values (((item0 deque) (dequeue-front deque))
                    ((item1 deque) (dequeue-front deque))
                    ((item2 deque) (dequeue-front deque))
                    ((item3 deque) (dequeue-front deque))
                    ((item4 deque) (dequeue-front deque)))
        (assert-eqv 4 item0)
        (assert-eqv 2 item1)
        (assert-eqv 0 item2)
        (assert-eqv 1 item3)
        (assert-eqv 3 item4)))
    (let ((deq (fold-left (lambda (deque item)
                        (enqueue-rear deque item))
                      (make-deque)
                      '(0 1 2))))
      (let*-values (((item0 deque0) (dequeue-rear deq))
                    ((item1 deque1) (dequeue-front deque0))
                    ((item2 deque2) (dequeue-rear deque1)))
        (assert-eqv 2 item0)
        (assert-eqv 0 item1)
        (assert-eqv 1 item2)
        (assert-predicate deque-empty? deque2))))
  
  (define-test-case deques list-conversion ()
    (let ((id-list (lambda (list)
                     (deque->list (list->deque list))))
          (l1 '())
          (l2 '(1 2 3))
          (l3 '(4 5 6 7 8 9 10))
          (l4 (string->list "abcdefghijklmnopqrstuvwxyz")))
      (assert-equal l1 (id-list l1))
      (assert-equal l2 (id-list l2))
      (assert-equal l3 (id-list l3))
      (assert-equal l4 (id-list l4))))
  
)
